// ============================================================================
// CONSONANT LABS CONTROL PLANE - PRISMA SCHEMA
// ============================================================================
//
// This schema defines the complete data model for the control plane.
// It supports multi-tenancy, secure authentication, and time-series telemetry.
//
// Key Design Principles:
// - Multi-database support (PostgreSQL, SQLite) via runtime adapter
// - Organization-scoped data isolation
// - Secure secret storage (bcrypt hashing)
// - TimescaleDB hypertables for time-series data
// - Optimized indexes for common query patterns

generator client {
  provider = "prisma-client-js"
}

// ⚠️ DO NOT CHANGE THIS LINE MANUALLY
// Managed by scripts/sync-provider.js - detects from DATABASE_URL at runtime
datasource db {
  provider = "postgresql"
}

// ============================================================================
// USER & ORGANIZATION MANAGEMENT
// ============================================================================

/// User account in the system
/// Users belong to organizations and can have multiple API keys
model User {
  id           String               @id @default(uuid())
  email        String               @unique
  name         String?
  passwordHash String?
  createdAt    DateTime             @default(now())
  updatedAt    DateTime             @updatedAt

  // Relations
  organizations OrganizationMember[]

  @@index([email])
  @@map("users")
}

/// Organization model for multi-tenancy
/// All resources (clusters, API keys, telemetry) are scoped to organizations
model Organization {
  id        String   @id @default(uuid())
  name      String
  slug      String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  members  OrganizationMember[]
  apiKeys  ApiKey[]
  clusters Cluster[]
  agents   Agent[]
  auditLogs AuditLog[]
  requestLogs RequestLog[]

  @@index([slug])
  @@map("organizations")
}

/// Many-to-many relationship between users and organizations
model OrganizationMember {
  id             String   @id @default(uuid())
  userId         String
  organizationId String
  role           OrgRole  @default(MEMBER)
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  user         User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  organization Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  @@unique([userId, organizationId])
  @@index([userId])
  @@index([organizationId])
  @@map("organization_members")
}

enum OrgRole {
  OWNER
  ADMIN
  MEMBER
  VIEWER
}

// ============================================================================
// API KEY MANAGEMENT
// ============================================================================

/// API key for REST API authentication
/// CRITICAL: Keys are hashed with bcrypt before storage (never plaintext)
/// Separate from cluster secrets - used only for REST API access
model ApiKey {
  id             String       @id @default(uuid())
  organizationId String
  name           String
  keyHash        String // bcrypt hash of the actual API key
  keyPrefix      String // First 8 chars of key for O(1) lookup
  lastUsedAt     DateTime?
  expiresAt      DateTime?
  revokedAt      DateTime?
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt

  // Rate limiting metadata
  rateLimit      Int          @default(100) // Requests per minute
  rateLimitUsed  Int          @default(0)
  rateLimitReset DateTime @default(now()) // When counter resets

  organization Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  @@index([organizationId])
  @@index([keyPrefix]) // Performance optimization
  @@index([keyHash])
  @@index([expiresAt])
  clusters   Cluster[] // Clusters registered with this key

  @@map("api_keys")
}


// ============================================================================
// AGENT REGISTRY
// ============================================================================

/// Agent definition - stores metadata about agents that can be executed.
/// Each agent defines a Docker container image and how to run it.
/// This is a one-time registration, then the agent can be executed many times.
model Agent {
  id             String   @id @default(uuid())
  organizationId String   // Which organization owns this agent
  name           String   // Human-readable name like "complaint-analyzer"
  image          String   // Docker image URL: docker.io/company/agent:v1
  description    String?  // Optional description for documentation
  
  // Canonical hash of config for upsert diffing
  // Generated from: name + image + resources + retryPolicy
  configHash     String   // SHA-256 hash of config for change detection
  
  // Registration status
  status         AgentStatus @default(PENDING)
  
  // Resource requirements (stored as JSON for flexibility)
  // Example: {cpu: "2", memory: "4Gi", gpu: "1", timeout: "300s"}
  resources   Json
  
  // Retry policy (stored as JSON)
  // Example: {maxAttempts: 3, backoff: "exponential", initialDelay: "1s"}
  retryPolicy Json
  
  // Optional advanced features
  useAgentSandbox Boolean @default(false) // Enable gVisor kernel isolation
  warmPoolSize    Int     @default(0)     // Pre-warmed instances (0 = disabled)
  networkPolicy   String  @default("standard") // restricted, standard, unrestricted
  
  // Environment variables passed to agent container
  environmentVariables Json? // {KEY: "value"}
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  organization Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  cluster      Cluster?     @relation(fields: [clusterId], references: [id])
  clusterId    String?      // Optional pinning to specific cluster
  executions   Execution[]

  @@unique([organizationId, name]) // Agent names must be unique per organization
  @@index([organizationId])        // Fast lookup of all agents for an organization
  @@index([configHash])            // Fast lookup by config hash for upsert
  @@map("agents")
}

enum AgentStatus {
  PENDING
  ACTIVE
  INACTIVE
  FAILED
}

// ============================================================================
// CLUSTER MANAGEMENT
// ============================================================================

/// Kubernetes cluster registered with the control plane
/// Clusters authenticate via cluster secrets (NOT API keys)
/// Connection endpoint: consonantlabs.xyz/{orgId}/stream
model Cluster {
  id             String        @id @default(uuid())
  organizationId String
  name           String
  namespace      String        @default("default")

  // Cluster capabilities (stored as JSON)
  // Example: {kubernetes: {version: "1.28"}, resources: {totalCpu: "32", totalMemory: "128Gi"}}
  capabilities  Json
  
  // Cluster secret for gRPC authentication (bcrypt hashed)
  secretHash     String
  
  status         ClusterStatus @default(PENDING)
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt
  lastHeartbeat    DateTime? // Last time we heard from this cluster

  // Relayer metadata
  relayerVersion String?
  relayerConfig  Json?

  // gRPC stream tracking (ephemeral - not persisted to DB in production)
  // In production, this is tracked in memory by the gRPC server
  streamId         String?   // Internal ID for the active gRPC stream
  organization Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  
  apiKey       ApiKey?      @relation(fields: [apiKeyId], references: [id])
  apiKeyId     String?      // Which API Key registered this cluster

  agents       Agent[]      // Agents pinned or assigned to this cluster
  executions   Execution[]

  // Relations to telemetry data
  traces         Trace[]
  metrics        Metric[]
  logs           Log[]
  events         Event[]

  @@unique([organizationId, name])
  @@index([organizationId])
  @@index([status])
  @@index([lastHeartbeat]) // Performance optimization
  @@map("clusters")
}

enum ClusterStatus {
  PENDING   // Registered but not connected
  ACTIVE    // Currently connected via gRPC
  INACTIVE  // Previously connected, now offline
  FAILED    // Connection or configuration issues
}


// ============================================================================
// EXECUTION TRACKING (HOT PATH - HIGHLY OPTIMIZED)
// ============================================================================

/// Execution record - tracks every time an agent runs.
/// This is the CORE of the system and the hottest path in the database.
/// The state machine: pending → queued → running → completed/failed
///
/// PERFORMANCE CRITICAL: This table receives:
/// - High write volume (every execution creates a record)
/// - High update volume (status changes multiple times per execution)  
/// - High read volume (users query execution status)
///
/// OPTIMIZATION STRATEGY:
/// - Minimal columns for fast writes
/// - Strategic indexes for common queries
/// - JSON for flexible data without schema changes
/// - Use typed SQL ($queryRaw) for hot path queries
model Execution {
  id        String   @id @default(uuid())
  agentId   String   // Which agent is being executed
  clusterId String?  // Which cluster is running this execution (optional until selected)
  
  // Execution state machine
  status    ExecutionStatus @default(PENDING)
  priority  Priority        @default(NORMAL)
  
  // Data flow
  input     Json     // Input data passed to agent (from SDK)
  result    Json?    // Output from agent (null until completed)
  error     String?  // Error message if failed
  
  // Timing (critical for SLAs and billing)
  queuedAt     DateTime? // When queued to cluster
  startedAt    DateTime? // When agent actually started running
  completedAt  DateTime? // When execution finished
  lastStatusUpdate DateTime? // When the last status event was received
  durationMs   Int?      // Total execution time in milliseconds
  
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt
  
  // Resource usage for billing (stored as JSON)
  // Example: {cpuSeconds: 120, memoryMbSeconds: 48000, gpuSeconds: 60}
  resourceUsage Json?
  
  // Retry tracking
  attempt        Int    @default(1)    // Current attempt number (1 = first try)
  maxAttempts    Int    @default(3)    // Max retries from agent's retry policy
  nextRetryAt    DateTime? // When to retry if failed
  
  // Relations
  agent   Agent    @relation(fields: [agentId], references: [id], onDelete: Cascade)
  cluster Cluster? @relation(fields: [clusterId], references: [id])
  logs    Log[]   // One-to-many with log entries

  // Strategic indexes for hot path queries
  @@index([agentId, createdAt(sort: Desc)]) // "Show me recent executions for this agent"
  @@index([clusterId, status])               // "Show me active executions on this cluster"
  @@index([status, createdAt])               // "Show me all pending executions"
  @@index([createdAt(sort: Desc)])           // "Show me recent executions" (global view)
  @@map("executions")
}

enum ExecutionStatus {
  PENDING
  QUEUED
  RUNNING
  COMPLETED
  FAILED
  TIMED_OUT
  CANCELLED
}

enum Priority {
  HIGH
  NORMAL
  LOW
}

// ============================================================================
// TIME-SERIES TELEMETRY DATA (TimescaleDB Hypertables)
// ============================================================================
//
// These models are designed to be TimescaleDB hypertables in production.
// Partitioned by time and org_id for optimal query performance.
//
// To enable TimescaleDB (run after migrations):
// SELECT create_hypertable('traces', 'timestamp');
// SELECT create_hypertable('metrics', 'timestamp');
// SELECT create_hypertable('logs', 'timestamp');

/// Distributed trace span data
/// Each span represents a single operation in a distributed system

/// OpenTelemetry trace span from agent execution.
/// Provides detailed execution timeline for debugging performance issues.
/// Also stored in TimescaleDB hypertable.
///
/// TIMESCALEDB SETUP:
/// SELECT create_hypertable('traces', 'timestamp', chunk_time_interval => INTERVAL '1 day');
model Trace {
  id             String   @id @default(uuid())
  organizationId String
  executionId String   // Which execution this trace belongs to
  clusterId      String
  traceId        String   // W3C Trace Context trace ID
  spanId         String   // W3C Trace Context span ID
  parentSpanId   String?  // Parent span ID for nested operations
  name           String   // Span name (e.g., "GET /api/users")
  kind           String   // Span kind: CLIENT, SERVER, PRODUCER, CONSUMER, INTERNAL
  timestamp      DateTime // Span start time (used for partitioning)
  duration       Int      // Duration in microseconds
  statusCode     String?  // HTTP status code or gRPC status
  statusMessage  String?  // Error message if failed
  attributes     Json?    // Span attributes as JSON
  events         Json?    // Span events (logs within span)
  links          Json?    // Links to other spans
  resource       Json?    // Resource attributes (service name, host, etc.)

  cluster Cluster @relation(fields: [clusterId], references: [id], onDelete: Cascade)

  @@index([executionId, timestamp(sort: Desc)])
  @@index([traceId, timestamp])
  @@index([clusterId, timestamp(sort: Desc)])
  @@index([name])
  @@map("traces")
}

/// Time-series metric data points
/// Supports gauges, counters, histograms, and summaries
/// Resource usage metric from agent execution.
/// Collected periodically during execution for billing and monitoring.
/// Stored in TimescaleDB hypertable.
///
/// TIMESCALEDB SETUP:
/// SELECT create_hypertable('metrics', 'timestamp', chunk_time_interval => INTERVAL '1 hour');
model Metric {
  id             String   @id @default(uuid())
  organizationId String
  executionId    String
  clusterId      String
  name           String   // Metric name (e.g., "http.server.request.duration")
  type           String   // Metric type: GAUGE, COUNTER, HISTOGRAM, SUMMARY
  timestamp      DateTime // Measurement timestamp (used for partitioning)
  value          Float    // Metric value
  unit           String?  // Unit (e.g., "ms", "bytes", "1")
  attributes     Json?    // Metric attributes/labels as JSON
  resource       Json?    // Resource attributes

  cluster Cluster @relation(fields: [clusterId], references: [id], onDelete: Cascade)

  @@index([executionId, timestamp(sort: Desc)])
  @@index([clusterId, timestamp(sort: Desc)])
  @@index([name])
  @@map("metrics")
}

/// Structured log events
/// Contains application logs, system logs, and audit logs
model Log {
  id             String   @id @default(uuid())
  organizationId String
  executionId String   // Which execution this log belongs to
  clusterId      String
  timestamp      DateTime // Log timestamp (used for partitioning)
  severity       String   // Log level: TRACE, DEBUG, INFO, WARN, ERROR, FATAL
  message        String   // Log message
  traceId        String?  // Associated trace ID
  spanId         String?  // Associated span ID
  attributes     Json?    // Log attributes as JSON
  resource       Json?    // Resource attributes
   stream      String   // stdout or stderr
  
  // Optional structured data extracted from JSON logs
  metadata    Json?    // Additional structured data if log is JSON
  
  // Relations
  execution Execution @relation(fields: [executionId], references: [id], onDelete: Cascade)

  cluster Cluster @relation(fields: [clusterId], references: [id], onDelete: Cascade)

   // TimescaleDB optimized indexes
  @@index([executionId, timestamp(sort: Desc)]) // "Show me logs for this execution"
  @@index([timestamp(sort: Desc)])              // "Show me recent logs"
  @@index([severity, timestamp])                // "Show me all errors"
  @@index([organizationId, timestamp(sort: Desc)])
  @@index([clusterId, timestamp(sort: Desc)])
  @@index([severity])
  @@index([traceId])
  @@map("logs")
}



/// Generic event log for cluster and system events
model Event {
  id             String   @id @default(uuid())
  eventId        String   @unique
  clusterId      String
  eventType      String
  severity       String
  source         String?
  timestamp      DateTime @default(now())
  payload        Json?
  metadata       Json?
  createdAt      DateTime @default(now())

  cluster Cluster @relation(fields: [clusterId], references: [id], onDelete: Cascade)

  @@index([clusterId, timestamp(sort: Desc)])
  @@index([eventType, timestamp])
  @@map("events")
}



// ============================================================================
// AUDIT & MONITORING
// ============================================================================

/// Audit log for administrative actions
model AuditLog {
  id             String   @id @default(uuid())
  organizationId String
  userId         String?
  action         String   // e.g., "AGENT_CREATED", "API_KEY_ROTATED"
  resourceType   String   // e.g., "Agent", "ApiKey"
  resourceId     String
  metadata       Json?    // Contextual data (diffs, etc.)
  ipAddress      String?
  userAgent      String?
  timestamp      DateTime @default(now())

  organization Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  @@index([organizationId, timestamp(sort: Desc)])
  @@index([resourceType, resourceId])
  @@map("audit_logs")
}

/// Detailed log of every API request for the "Timeline" UI
model RequestLog {
  id             String   @id @default(uuid())
  organizationId String?
  apiKeyId       String?
  method         String   // GET, POST, etc.
  path           String
  statusCode     Int
  durationMs     Int      // Process timing
  ipAddress      String?
  userAgent      String?
  requestId      String   @unique // X-Request-ID
  timestamp      DateTime @default(now())
  
  // Timing breakdown (JSON for flexibility)
  // { auth: 2, db: 10, inngest: 5 }
  timeline       Json?

  organization Organization? @relation(fields: [organizationId], references: [id])

  @@index([organizationId, timestamp(sort: Desc)])
  @@index([requestId])
  @@map("request_logs")
}
